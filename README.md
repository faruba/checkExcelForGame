设计初衷当然是帮助策划检查表格,尽量减少因为表格配置错误导致的程序报错.
从而减少 
 1.策划找程序查配置问题
 2.错误数据更新到外网导致的buy 以及后续的数据修复

 检查函数肯定是由程序完成,如果可以让策划自己维护检查规则,就更好了,退一万步说,如果策划不维护,
 检查规则,程序应该也不需要花大力气维护规则.所以我决定设计一个语言,方便做表格检查 ;)

 parse.py 是检查语言(我命名为littleChecker aka: lc) 词法解析器, 依赖于 PLY,如果由编译原理的知识,或者懂Lisp 或 Prolog, 应该很容易看懂. 如果要增加语言机制,就在这里实现
 列名=验证函数列表,用;分隔,必须所有的验证通过才算通过
 验证函数接受0到多个参数,参数可以是字符串,数组,token
 验证函数支持条件开关[]中是条件检查列表,支持 |(or) &(and), ()括号分组, 计算为真才做 => 后面的验证,
 条件检查 由 列名 判断符号 值组成 (我有些纠结要不要支持函数,这样扩展性无疑是最高的,但一方面觉得,如果条件表达式过于繁琐,通常意味着表结构设计上出现了问题(也不一定,可能只是过于通用,比如活动的 CustomCfg, 道具表的 ItemParam),如果要通用到这种程度才能检查出来,我想做表格翻译或许更容易一些,顺便做个检查就足够了)

 tableCache.py 表格检查的特点就是跨表,策划平时的工作特性是只改部分表格,如果每次都要读取所有的表格,效率是在时低下.这个类主要就是基于md5 检测文件是否变化,然后导出为csv,方便相应的库快速读取.同时提供惰性载入的机制,没有涉及到的表格,没必要读取

 checker.py 检查函数,想支持什么检查,就在这里补充好了

 checkerRun.py 把所有模块整合在一起的类, 解析ast, 调用checker, 对数据进行验证
 mycfg.py 简单的configparser 封装
 layout.py 界面布局,工具生成,但凡不是生成的代码,都不能写在这
 guicontrol.py 所有ui的逻辑写在这个里即可
 guifunc.py 一些比较通用的函数.感觉其他工具可以用得到

 main.py 载入环境,运行 checkerRun.


语法:
1.规则文件名和excel名字一样(文件类型不一样) 比如 ActivityControl.txt,只有拥有同名规则文件才会做检查
2.每行由 检查的列名=检查表达式 组成;检查表达式可以有多个,用 ;分隔
3.表达式有2种模式  检查函数(检查参数) , [条件判断]=>检查函数(检查参数) 前者检查列中所有函数, 后者只有条件判断通过才检查.
@SameAs 是关键字. 参数只能是列名.用于公用检查配置.

目前支持的检查函数有:
1.Uniq() 不接受任何参数, 该列数据不允许有重复值
2.Type() 检查列中数据类型,   多参数代表可以是多种数据类型 比如 Type(Number,NA) 意味着可以是数字或者不填.
支持数组结构检查.Type([Number,Number,Number]) 对应{1,1,2}.同理 Type([[Number,Number,Number]])  对应 {{1,1,2},{1,1,3},...} 这种结构.
2.1 目前Type 支持的数据类型有 Number,String, Color(就是16进制字符串), NA(代表不填), Time("timeFmt"), 

3.IN 用于检查数据是否存在于另外列中(可跨文件),检查数据合法性. IN(表名(@代表本表), 列名, 数据提取器(可选)) ,该函数会自动忽略 空数据
  举例: MainActivity=Type(Number,NA);IN(@,ActivityID) 要求 MainActivity中的数据 必须在本表的ActivityID列中找到
      Pack=Type([[Number,Number,Number]]);[ID!=3008]=>IN(ItemType,ItemID,"*.1") Pack 列 中 所有数组元素的第2个数字必须在 ItemType 表中的ItemID 列找到
4.Range, 数据内容范围检查,  Range([1,2,NA],Array) 指数据只能是1,2,或者不填. Range([1,7],FromTo) 指数据只能是1~7的整数.

数据提取器 
    1. 支持多结构提取 比如 "*.1|1" 会对 二维数组用"*.1"的方式提取, 对一维数组用 "1"的方式提取. 
    2. 如果 传入的是"$" 并且目标内容是一个数组, 会根据数组内容组装成一个 用0 隔断的数字.比如 [1,2] 会返回 102 [1,2,3] 返回 10203,监测二级索引比较有用
    3. 如果 传入的是 "@xx" xx 可以是 数字 比如 "@2" 也可以是字符串 "@'2'" 意味着 就是 xx值本身. 这用于监测当这个列配置时,希望另外一个表相应的值也存在.(见 HeroLevel BaseMoney1)



2.2 理论上还支持 检查表达式,好处就是扩展性强,但是感觉会引入复杂度,设计这门语言的初衷是希望可以让策划维护(毕竟策划会改表,条件判断可能会变化),对策划雪藏.

比如  StartTime=[OpenType=7]=>Type([Range([1,7],FromTo),Time("%H:%M:%S")]) 这种也是支持的, 意思是 如果openType是7的活动, StartTime 是个数组,第一数据只能是1-7(代表星期1-星期日), 第二个数一个时间字符串. 这个检查比  StartTime=[OpenType=7]=>Type(Number,Time("%H:%M:%S")]) 要严格.

如果某列数据是数组, 还支持 [列名@idx=xxx] 的结构,比如
RedPackets.txt Condition=Type(NA,[String,Number]);[Condition@0="Pay"]=>IN(Pay,payId,"1");[Condition@0="Task"]=>IN(Task,ID,"1")
表中数据类似 
Condition
{Pay,8083}
{Task,1500001}


完整例子  见 rule/AcrivityControl.txt 和 rule/Pack.txt
---------------------------------------------

开发文档见main.py 有结构目录和注释. 通常只需要扩展 checker.py 
如果想增加语言机制,可以改 parser.py 和 checkerRun.py
如果要增加 ui 功能, 可以改 layout.py(工具生成的,记得载入 后编辑再导出,menu 是根据配置生成的,没用工具的自带功能,要小心会不会解析失败) 和 guicontrol.py(非自动生成的ui代码都在这里,别往layout.py里写,除非想自己写布局)


